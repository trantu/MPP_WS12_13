#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry true
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Mikroprozessorpraktikum WS 12/13
\end_layout

\begin_layout Author
Carlos Martín Nieto, Simon Hohberg, Tu Tran
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
setcounter{section}{9}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Der DMA Controller des MSP430F1612
\end_layout

\begin_layout Subsection
Schnelles Senden eines Buffers über die UART im DMA_Mode
\end_layout

\begin_layout Subsubsection
Entwickeln Sie ein Programm, das folgende Funktionalitäten bietet: 
\end_layout

\begin_layout Itemize
Definieren Sie eine Variable char uart_buffer[100];
\end_layout

\begin_layout Itemize
Initialisieren Sie die Variable mit einer Zeichenkette der Länge Null
\end_layout

\begin_layout Itemize
Bei Druck auf die Taste P1.0 sollen neue Sensorwerte wie in A 7.3.1 eingelesen
 werden
\end_layout

\begin_layout Itemize
Die Sensorwete sollen in die Variable per sprintf() eingetragen werden.
\end_layout

\begin_layout Itemize
Danach sollen diese Daten per DMA an die UART geschickt werden
\end_layout

\begin_layout Itemize
Initialisieren Sie die DMA in der Form, dass die Zeichenkette aus der Varible
 auf die Serielle Schnittstelle ausgegeben wird
\end_layout

\begin_layout Itemize
Die Anzahl der Bytes bestimmen Sie aus der Länge der Zeichenkette
\end_layout

\begin_layout Itemize
Schalten Sie beim Start des DMA Datentransfers die LED P4.0 ein und am Ende
 des Datentransfers (in der ISR) aus
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,frame=single,language=C,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

//----------------------------- init.c ------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void init_UART1(void)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

	//	P3SEL .....;			// USART RX und TX dem Modul zuweisen
\end_layout

\begin_layout Plain Layout

	P3SEL = BIT6 | BIT7;
\end_layout

\begin_layout Plain Layout

	//	U1CTL .....; 			// Reset
\end_layout

\begin_layout Plain Layout

	U1CTL = SWRST;
\end_layout

\begin_layout Plain Layout

	//	U1CTL .....; 			// Format 8N1
\end_layout

\begin_layout Plain Layout

	U1CTL |= CHAR; // 8 Bits Daten, keine Paritaet und 1-Bit Stop ist default
\end_layout

\begin_layout Plain Layout

	//	U1TCTL.....;			// Taktquelle SMCLK
\end_layout

\begin_layout Plain Layout

	U1TCTL |= SSEL0 + SSEL1; // Taktquelle SMCLK
\end_layout

\begin_layout Plain Layout

	//	U1BR0 .....;  			// Teiler Low-Teil, da 7372800/64 ca.
 115200
\end_layout

\begin_layout Plain Layout

	U1BR0 = 64; //7372800/64 ca.
 115200
\end_layout

\begin_layout Plain Layout

	U1BR1 = 0;
\end_layout

\begin_layout Plain Layout

	//	U1BR1 .....;			// Teiler High-Teil
\end_layout

\begin_layout Plain Layout

	//	U1MCTL ....; 			// Modulationskontrolle
\end_layout

\begin_layout Plain Layout

	U1MCTL = 0;
\end_layout

\begin_layout Plain Layout

	//	ME2 .......;			// Enable USART1 TXD/RXD
\end_layout

\begin_layout Plain Layout

	ME2 = BIT5 + BIT4;
\end_layout

\begin_layout Plain Layout

	//	U1CTL .....;	 		// Reset
\end_layout

\begin_layout Plain Layout

	U1CTL &= ~SWRST;
\end_layout

\begin_layout Plain Layout

	//	IE2 .......;			// Enable Interrupt
\end_layout

\begin_layout Plain Layout

	//IE2 = BIT4;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//----------------------------- main.c ------------------------------------
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//=========================================================================
\end_layout

\begin_layout Plain Layout

//=== Startprojekt zum Mikroprozessorpraktikum ============================
\end_layout

\begin_layout Plain Layout

//=========================================================================
\end_layout

\begin_layout Plain Layout

#include "msp430x16x.h"		// Systemdefinitionen für den MSP430F1612
\end_layout

\begin_layout Plain Layout

#include "init.h"			// Initialisierung des Mikrocontrollers
\end_layout

\begin_layout Plain Layout

#include "system.h"			// Systemfunktionen MSB430H
\end_layout

\begin_layout Plain Layout

#include "interrupts.h"		// ISR - Interrupt Service Routinen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include "HW_CC1100.h"		// CC1100 868MHz Funk Transceiver
\end_layout

\begin_layout Plain Layout

#include "HW_SHT11.h"		// SHT11 Feuchte- und Temperatursensor
\end_layout

\begin_layout Plain Layout

#include "HW_MMA7260Q.h"	// MMA7260Q 3D-Beschleunigungssensor
\end_layout

\begin_layout Plain Layout

#include "HW_LCD_TS.h"		// DOGM128 LCD Display Touchscreen
\end_layout

\begin_layout Plain Layout

#include "HW_LCD.h"			// DOGM128 LCD Display 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#include "stdio.h"			// Standard Libary 
\end_layout

\begin_layout Plain Layout

#include "string.h"			// Standard Libary 
\end_layout

\begin_layout Plain Layout

#include "math.h"			// Standard Libary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//#include "aufgabe_x.h"	// Header Datei für aufgabe_x.c 
\end_layout

\begin_layout Plain Layout

							// möglichst eigene xxx.h und xxx.c Dateien
\end_layout

\begin_layout Plain Layout

							// erstellen und verwenden.
\end_layout

\begin_layout Plain Layout

main(void);					//Haupprogramm
\end_layout

\begin_layout Plain Layout

void print_value(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define BIT_SET(a,b) ((a) |= (b))
\end_layout

\begin_layout Plain Layout

#define BIT_CLR(a,b) ((a) &= ~(b))
\end_layout

\begin_layout Plain Layout

#define BIT_TOGGLE(a,b) ((a) ^= (b))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//====Hauptprogramm=======================================================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

char uart_buffer[100] = { '
\backslash
0' };
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void print_buf(const char *str)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	do {
\end_layout

\begin_layout Plain Layout

		U1TXBUF = *str;
\end_layout

\begin_layout Plain Layout

		while (!(U1TCTL & TXEPT));
\end_layout

\begin_layout Plain Layout

	} while(*str++);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main(void)
\end_layout

\begin_layout Plain Layout

	{
\end_layout

\begin_layout Plain Layout

//===Hier sollten Variablen deklariert werden ============================
\end_layout

\begin_layout Plain Layout

	//unsigned char i = 0;
\end_layout

\begin_layout Plain Layout

	//char text[60];
\end_layout

\begin_layout Plain Layout

	//int x,y;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

//===Hier die notwendigen Initialisierungsschritte =======================
\end_layout

\begin_layout Plain Layout

//=(1)== Port-Initialisierung ============================================
\end_layout

\begin_layout Plain Layout

	init_Port();				// Initialisierung der Port Register
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

//(2)=== Clock-System-Initialisierung ====================================
\end_layout

\begin_layout Plain Layout

	//== XT2() oder Dco() als Taktquelle einstellen
\end_layout

\begin_layout Plain Layout

	//== durch Ein- oder Auskommentieren
\end_layout

\begin_layout Plain Layout

	//== DCO ist bei LPM Einsatz bevorzugt muß zyklisch kalibriert werden
\end_layout

\begin_layout Plain Layout

	//== XT2 ist quarzstabil muß nicht zyklisch kalibriert werden
\end_layout

\begin_layout Plain Layout

	//  			
\end_layout

\begin_layout Plain Layout

	//XT2 ();					// XT2 Taktquelle aktivieren mit 7.3728MHz
\end_layout

\begin_layout Plain Layout

	DCO ();					// Dco Taktquelle aktivieren mit 7.3728MHz
\end_layout

\begin_layout Plain Layout

	//						   beachte DELTA
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

//=(3)== Timer-Initialisierung= ==========================================
\end_layout

\begin_layout Plain Layout

	init_Timer_A();			// Init Timer für Sekundeninterrupt
\end_layout

\begin_layout Plain Layout

							// !! noch leere Funktion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//=(4)== USART-Initialisierung ===========================================
\end_layout

\begin_layout Plain Layout

	init_UART1();			// UART-RS232 mit 115.2kBit/s initialisieren
\end_layout

\begin_layout Plain Layout

							// !! noch leere Funktion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//=(5)== CC1100-Transceiver-Initialisierung ==============================
\end_layout

\begin_layout Plain Layout

	init_UART0_SPI();		// CC1100 SPI UART initalisieren
\end_layout

\begin_layout Plain Layout

	init_CC1100_POWERDOWN();			// CC1100 init und in RX Mode setzen
\end_layout

\begin_layout Plain Layout

							// !!!Interrupte sind ab jetzt freigegeben!!
\end_layout

\begin_layout Plain Layout

	//== Adresse und Funkkanal des Transceivers setzen
\end_layout

\begin_layout Plain Layout

	//== für die Arbeitsplaetze HWPx (x=1...10) sollten
\end_layout

\begin_layout Plain Layout

	//== ID=x und channnel=x gesetzt werden
\end_layout

\begin_layout Plain Layout

	ID = 1;							// Adresse 
\end_layout

\begin_layout Plain Layout

	setUid(ID);						// Adresse im Transceiver setzen 
\end_layout

\begin_layout Plain Layout

	channel = 1; 					// Funkkanal  
\end_layout

\begin_layout Plain Layout

	switchFreq(channel);			// Funkkanal im Transceiver setzen 
\end_layout

\begin_layout Plain Layout

	//== Soll der Transceiver genutzt werden müssen folgende zwei Zeilen  
\end_layout

\begin_layout Plain Layout

	//== auskommentiert werden: 
\end_layout

\begin_layout Plain Layout

	init_CC1100_IDLE();		// CC1100 in den IDLE Mode setzen
\end_layout

\begin_layout Plain Layout

	init_CC1100_POWERDOWN();// CC1100 in den PowerDown Mode setzen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//=(6)== LCD-Display-Initialisierung =====================================
\end_layout

\begin_layout Plain Layout

	dogm_reset();		// Hardware Reset des LCD Controllers
\end_layout

\begin_layout Plain Layout

	dogm_init();		// Initialisierung der LCD Controller Register
\end_layout

\begin_layout Plain Layout

	lcd_clear(WHITE);	// Grafikspeicher auf dem MSP430 löschen
\end_layout

\begin_layout Plain Layout

	//lcd_string(BLACK, 15, 25, "MSP430-GESTARTET!");	// Textausgabe
\end_layout

\begin_layout Plain Layout

	lcd_paint();		// Grafikspeicher auf das LCD Display ausgeben
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define LED_ROT (0x01)   // 0 0 1 P4.0
\end_layout

\begin_layout Plain Layout

#define LED_GELB (0x02)  // 0 1 0 P4.1
\end_layout

\begin_layout Plain Layout

#define LED_GRUEN (0x04) // 1 0 0 P4.2
\end_layout

\begin_layout Plain Layout

#define LED_ALL (LED_ROT | LED_GELB | LED_GRUEN)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define LED_ON(led) (BIT_CLR(P4OUT, led)) 
\end_layout

\begin_layout Plain Layout

#define LED_OFF(led) (BIT_SET(P4OUT, led)) 
\end_layout

\begin_layout Plain Layout

#define LED_TOGGLE(led) (BIT_TOGGLE(P4OUT, led))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define IS_LED_ON(led) (!(P4OUT & led))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define TASTE_LINKS (0x1)
\end_layout

\begin_layout Plain Layout

#define TASTE_RECHTS (0x2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#define SLEEP_QUANTUM 10000
\end_layout

\begin_layout Plain Layout

#define SLEEP(n) do { 		/* sleep for n seconds */ 
\backslash

\end_layout

\begin_layout Plain Layout

	long time = n * 100000; /* wait() sleeps 10*n microseconds */ 
\backslash

\end_layout

\begin_layout Plain Layout

	while(time > SLEEP_QUANTUM) { 
\backslash

\end_layout

\begin_layout Plain Layout

		wait(SLEEP_QUANTUM); 
\backslash

\end_layout

\begin_layout Plain Layout

		time -= SLEEP_QUANTUM; 
\backslash

\end_layout

\begin_layout Plain Layout

	} 
\backslash

\end_layout

\begin_layout Plain Layout

	wait(time); 
\backslash

\end_layout

\begin_layout Plain Layout

} while(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

BIT_CLR(P1DIR, TASTE_LINKS);
\end_layout

\begin_layout Plain Layout

BIT_CLR(P1IES, TASTE_LINKS); // LH
\end_layout

\begin_layout Plain Layout

BIT_SET(P1IE, TASTE_LINKS);
\end_layout

\begin_layout Plain Layout

BIT_CLR(P1IFG, TASTE_LINKS);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

_bis_SR_register(GIE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

memset(uart_buffer, 0, sizeof(uart_buffer));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

//===Hier die Endlosschleife quasi das Betriebssystem=====================
\end_layout

\begin_layout Plain Layout

while(1){
\end_layout

\begin_layout Plain Layout

	//SHT11_Read_Sensor();
\end_layout

\begin_layout Plain Layout

	//sprintf(uart_buffer, "%s %s
\backslash
r
\backslash
n", temp_char, humi_char);
\end_layout

\begin_layout Plain Layout

	//print_buf(uart_buffer);
\end_layout

\begin_layout Plain Layout

	//lcd_clear(WHITE);	// Grafikspeicher auf dem MSP430 löschen
\end_layout

\begin_layout Plain Layout

	//lcd_string(BLACK, 15, 25, uart_buffer);	// Textausgabe
\end_layout

\begin_layout Plain Layout

	//lcd_paint();		// Grafikspeicher auf das LCD Display ausgeben
\end_layout

\begin_layout Plain Layout

	//wait(30000);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

}	// Ende der Endlosschleife
\end_layout

\begin_layout Plain Layout

}	// Ende Main
\end_layout

\begin_layout Plain Layout

//====Ende des Hauptprogramms ============================================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#pragma vector = PORT1_VECTOR
\end_layout

\begin_layout Plain Layout

__interrupt void PORT1(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	if (P1IFG & TASTE_LINKS) {
\end_layout

\begin_layout Plain Layout

		BIT_CLR(P1IFG, TASTE_LINKS);
\end_layout

\begin_layout Plain Layout

		LED_ON(LED_ROT);
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		SHT11_Read_Sensor();
\end_layout

\begin_layout Plain Layout

		sprintf(uart_buffer, "%s %s
\backslash
r
\backslash
n", temp_char, humi_char);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// USART konfigurieren		
\end_layout

\begin_layout Plain Layout

		BIT_CLR(IFG2, UTXIFG1);	// interrupt flag loeschen
\end_layout

\begin_layout Plain Layout

		BIT_CLR(IE2, UTXIE1);	// interrupt ausschaulten
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		// DMA konfigurieren
\end_layout

\begin_layout Plain Layout

		DMA2SZ = strlen(uart_buffer);
\end_layout

\begin_layout Plain Layout

		DMA2DA = (unsigned int)&U1TXBUF; // speichere die Addresse des TX Buffers
\end_layout

\begin_layout Plain Layout

		DMA2SA = (unsigned int)uart_buffer; // und die von unserem String
\end_layout

\begin_layout Plain Layout

		DMACTL0 = DMA2TSEL3 + DMA2TSEL1; // Trigger wenn TX IFG gestezt ist
\end_layout

\begin_layout Plain Layout

		// kopiere 1 Byte vom String ins TX Buffer bei jedem Transfer und erhoehe
 src um eins
\end_layout

\begin_layout Plain Layout

		DMA2CTL = DMAEN + DMASRCINCR0 + DMASRCINCR1 + DMADSTBYTE + DMASRCBYTE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		// Bescheid sagen, wenn der Transfer fertig ist
\end_layout

\begin_layout Plain Layout

		BIT_CLR(DMA2CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout

		DMA2CTL += DMAIE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

		BIT_SET(IFG2, UTXIFG1); // starte den ersten Transfer
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#pragma vector = DACDMA_VECTOR
\end_layout

\begin_layout Plain Layout

__interrupt void DMA(void)
\end_layout

\begin_layout Plain Layout

{
\end_layout

\begin_layout Plain Layout

	// ISR aufgerufen, wenn der Transfer fertig ist
\end_layout

\begin_layout Plain Layout

	if (DMA2CTL & DMAIFG) {
\end_layout

\begin_layout Plain Layout

		BIT_CLR(DMA2CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout

		// Lampe ausmachen, wir sind fertig
\end_layout

\begin_layout Plain Layout

		LED_OFF(LED_ROT);		
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Berechnen Sie auf Basis der Datenübertragungsrate die Zeit für die Übertragung
 der Zeichenkette.
 Überprüfen Sie messtechnisch mit dem Counter HM8021 die ermittelte Zeit.
 Nutzen Sie für die Messung den Port P1 Bit2 als Signalquelle.
 Beim Start der Übertragung setzen Sie das Bit auf "1" und beim Ende der
 Übertragung auf "0".
 Der Vorgang muß innerhalb einer Sekunde zyklisch ablaufen damit das Messgerät
 richtig funktioniert (also Tastendruck per Software emulieren).
\end_layout

\begin_layout Standard
Es werden 20 Byte gesendet:
\end_layout

\begin_layout Itemize
Berechnung: 
\begin_inset Formula $\frac{20\, Byte\cdot8}{115200\, Symbole(=Bit)/s}=\frac{160\, Bit\cdot s}{115,2\cdot10^{3}\, Bit}=1,3889\,\cdot10^{-3}\, s=\underline{1,3889\, ms}$
\end_inset


\end_layout

\begin_layout Itemize
1.
 Messung: 
\begin_inset Formula $1,73\, ms$
\end_inset


\end_layout

\begin_layout Itemize
2.
 Messung: 
\begin_inset Formula $1,77\, ms$
\end_inset


\end_layout

\begin_layout Subsection
Ausgabe von Analogwerten über den DA-Umsetzer im DMA_Mode 
\end_layout

\begin_layout Subsubsection
Verändern Sie die Lösung aus der Aufgabe A 9.1.1 in der Form, dass die Ausgabe
 der Sinuswerte auf den D/A-Wandler durch die DMA Einheit vorgenommen wird.
 
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,frame=single,language=C,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=========================================================================
\end_layout

\begin_layout Plain Layout
//=== Startprojekt zum Mikroprozessorpraktikum ============================
\end_layout

\begin_layout Plain Layout
//=========================================================================
\end_layout

\begin_layout Plain Layout
#include "msp430x16x.h"		// Systemdefinitionen für den MSP430F1612
\end_layout

\begin_layout Plain Layout
#include "init.h"			// Initialisierung des Mikrocontrollers
\end_layout

\begin_layout Plain Layout
#include "system.h"			// Systemfunktionen MSB430H
\end_layout

\begin_layout Plain Layout
#include "interrupts.h"		// ISR - Interrupt Service Routinen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#include "HW_CC1100.h"		// CC1100 868MHz Funk Transceiver
\end_layout

\begin_layout Plain Layout
#include "HW_SHT11.h"		// SHT11 Feuchte- und Temperatursensor
\end_layout

\begin_layout Plain Layout
#include "HW_MMA7260Q.h"	// MMA7260Q 3D-Beschleunigungssensor
\end_layout

\begin_layout Plain Layout
#include "HW_LCD_TS.h"		// DOGM128 LCD Display Touchscreen
\end_layout

\begin_layout Plain Layout
#include "HW_LCD.h"			// DOGM128 LCD Display 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#include "stdio.h"			// Standard Libary 
\end_layout

\begin_layout Plain Layout
#include "string.h"			// Standard Libary 
\end_layout

\begin_layout Plain Layout
#include "math.h"			// Standard Libary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//#include "aufgabe_x.h"	// Header Datei für aufgabe_x.c 
\end_layout

\begin_layout Plain Layout
							// möglichst eigene xxx.h und xxx.c Dateien
\end_layout

\begin_layout Plain Layout
							// erstellen und verwenden.
\end_layout

\begin_layout Plain Layout
main(void);					//Haupprogramm
\end_layout

\begin_layout Plain Layout
void print_value(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define BIT_SET(a,b) ((a) |= (b))
\end_layout

\begin_layout Plain Layout
#define BIT_CLR(a,b) ((a) &= ~(b))
\end_layout

\begin_layout Plain Layout
#define BIT_TOGGLE(a,b) ((a) ^= (b))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//====Hauptprogramm=======================================================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define SINUS_VALUES 100
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
int sinus[SINUS_VALUES];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
main(void)
\end_layout

\begin_layout Plain Layout
	{
\end_layout

\begin_layout Plain Layout
		float step;
\end_layout

\begin_layout Plain Layout
		int i;
\end_layout

\begin_layout Plain Layout
//===Hier sollten Variablen deklariert werden ============================
\end_layout

\begin_layout Plain Layout
	//unsigned char i = 0;
\end_layout

\begin_layout Plain Layout
	//char text[60];
\end_layout

\begin_layout Plain Layout
	//int x,y;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
//===Hier die notwendigen Initialisierungsschritte =======================
\end_layout

\begin_layout Plain Layout
//=(1)== Port-Initialisierung ============================================
\end_layout

\begin_layout Plain Layout
	init_Port();				// Initialisierung der Port Register
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
//(2)=== Clock-System-Initialisierung ====================================
\end_layout

\begin_layout Plain Layout
	//== XT2() oder Dco() als Taktquelle einstellen
\end_layout

\begin_layout Plain Layout
	//== durch Ein- oder Auskommentieren
\end_layout

\begin_layout Plain Layout
	//== DCO ist bei LPM Einsatz bevorzugt muß zyklisch kalibriert werden
\end_layout

\begin_layout Plain Layout
	//== XT2 ist quarzstabil muß nicht zyklisch kalibriert werden
\end_layout

\begin_layout Plain Layout
	//  			
\end_layout

\begin_layout Plain Layout
	//XT2 ();					// XT2 Taktquelle aktivieren mit 7.3728MHz
\end_layout

\begin_layout Plain Layout
	DCO ();					// Dco Taktquelle aktivieren mit 7.3728MHz
\end_layout

\begin_layout Plain Layout
	//						   beachte DELTA
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
//=(3)== Timer-Initialisierung= ==========================================
\end_layout

\begin_layout Plain Layout
	init_Timer_A();			// Init Timer für Sekundeninterrupt
\end_layout

\begin_layout Plain Layout
							// !! noch leere Funktion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=(4)== USART-Initialisierung ===========================================
\end_layout

\begin_layout Plain Layout
	init_UART1();			// UART-RS232 mit 115.2kBit/s initialisieren
\end_layout

\begin_layout Plain Layout
							// !! noch leere Funktion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=(5)== CC1100-Transceiver-Initialisierung ==============================
\end_layout

\begin_layout Plain Layout
	init_UART0_SPI();		// CC1100 SPI UART initalisieren
\end_layout

\begin_layout Plain Layout
	init_CC1100_POWERDOWN();			// CC1100 init und in RX Mode setzen
\end_layout

\begin_layout Plain Layout
							// !!!Interrupte sind ab jetzt freigegeben!!
\end_layout

\begin_layout Plain Layout
	//== Adresse und Funkkanal des Transceivers setzen
\end_layout

\begin_layout Plain Layout
	//== für die Arbeitsplaetze HWPx (x=1...10) sollten
\end_layout

\begin_layout Plain Layout
	//== ID=x und channnel=x gesetzt werden
\end_layout

\begin_layout Plain Layout
	ID = 1;							// Adresse 
\end_layout

\begin_layout Plain Layout
	setUid(ID);						// Adresse im Transceiver setzen 
\end_layout

\begin_layout Plain Layout
	channel = 1; 					// Funkkanal  
\end_layout

\begin_layout Plain Layout
	switchFreq(channel);			// Funkkanal im Transceiver setzen 
\end_layout

\begin_layout Plain Layout
	//== Soll der Transceiver genutzt werden müssen folgende zwei Zeilen  
\end_layout

\begin_layout Plain Layout
	//== auskommentiert werden: 
\end_layout

\begin_layout Plain Layout
	init_CC1100_IDLE();		// CC1100 in den IDLE Mode setzen
\end_layout

\begin_layout Plain Layout
	init_CC1100_POWERDOWN();// CC1100 in den PowerDown Mode setzen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=(6)== LCD-Display-Initialisierung =====================================
\end_layout

\begin_layout Plain Layout
	dogm_reset();		// Hardware Reset des LCD Controllers
\end_layout

\begin_layout Plain Layout
	dogm_init();		// Initialisierung der LCD Controller Register
\end_layout

\begin_layout Plain Layout
	lcd_clear(WHITE);	// Grafikspeicher auf dem MSP430 löschen
\end_layout

\begin_layout Plain Layout
	//lcd_string(BLACK, 15, 25, "MSP430-GESTARTET!");	// Textausgabe
\end_layout

\begin_layout Plain Layout
	lcd_paint();		// Grafikspeicher auf das LCD Display ausgeben
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define LED_ROT (0x01)   // 0 0 1 P4.0
\end_layout

\begin_layout Plain Layout
#define LED_GELB (0x02)  // 0 1 0 P4.1
\end_layout

\begin_layout Plain Layout
#define LED_GRUEN (0x04) // 1 0 0 P4.2
\end_layout

\begin_layout Plain Layout
#define LED_ALL (LED_ROT | LED_GELB | LED_GRUEN)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define LED_ON(led) (BIT_CLR(P4OUT, led)) 
\end_layout

\begin_layout Plain Layout
#define LED_OFF(led) (BIT_SET(P4OUT, led)) 
\end_layout

\begin_layout Plain Layout
#define LED_TOGGLE(led) (BIT_TOGGLE(P4OUT, led))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define IS_LED_ON(led) (!(P4OUT & led))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define TASTE_LINKS (0x1)
\end_layout

\begin_layout Plain Layout
#define TASTE_RECHTS (0x2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define SLEEP_QUANTUM 10000
\end_layout

\begin_layout Plain Layout
#define SLEEP(n) do { 		/* sleep for n seconds */ 
\backslash

\end_layout

\begin_layout Plain Layout
	long time = n * 100000; /* wait() sleeps 10*n microseconds */ 
\backslash

\end_layout

\begin_layout Plain Layout
	while(time > SLEEP_QUANTUM) { 
\backslash

\end_layout

\begin_layout Plain Layout
		wait(SLEEP_QUANTUM); 
\backslash

\end_layout

\begin_layout Plain Layout
		time -= SLEEP_QUANTUM; 
\backslash

\end_layout

\begin_layout Plain Layout
	} 
\backslash

\end_layout

\begin_layout Plain Layout
	wait(time); 
\backslash

\end_layout

\begin_layout Plain Layout
} while(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	// Schrittlaenge
\end_layout

\begin_layout Plain Layout
	step = (2*3.14159)/SINUS_VALUES;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// berechne Ausgangswerte fuer sinus
\end_layout

\begin_layout Plain Layout
	for (i = 0; i < SINUS_VALUES; i++) {
\end_layout

\begin_layout Plain Layout
		double x = sin(i*step);
\end_layout

\begin_layout Plain Layout
		x /= 2.0;	// Amplitude von sinus ist 2, wir moechten 1
\end_layout

\begin_layout Plain Layout
		x += 1.0;	// Gleichspannungsanteil, Verschiebung entlang der y-Achse
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		sinus[i] = x * ((double)4095/(double)3);	// 3V maximale Ausgangsspannung,
 12 Bit Aufloesung => 4096 Werte
\end_layout

\begin_layout Plain Layout
	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	BIT_SET(BCSCTL2, SELS); // waehle XT2CLK als SMCLK
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// waehle SMCLK (7.4 MHz ohne divider)
\end_layout

\begin_layout Plain Layout
	BIT_SET(TBCTL, TBSSEL1);
\end_layout

\begin_layout Plain Layout
	BIT_CLR(TBCTL, TBSSEL0);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// wahle count up mode
\end_layout

\begin_layout Plain Layout
	BIT_SET(TBCTL, MC0);
\end_layout

\begin_layout Plain Layout
	BIT_CLR(TBCTL, MC1);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// setze anzahl fuer interrupt
\end_layout

\begin_layout Plain Layout
	TBCCR0 = 740; // 7.4 MHz: takt=7_400_000 / 10000 = count to 740
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// loesche interrupt flag fuer timer
\end_layout

\begin_layout Plain Layout
	BIT_CLR(TBCCTL0, CCIFG);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	// 1x Referenzspannung, schnell
\end_layout

\begin_layout Plain Layout
	DAC12_1CTL = DAC12IR + DAC12AMP0 + DAC12AMP1 + DAC12AMP2 + DAC12SREF_2
 + DAC12CALON;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	// DMA konfigurieren
\end_layout

\begin_layout Plain Layout
	DMA2SZ = SINUS_VALUES;
\end_layout

\begin_layout Plain Layout
	DMA2DA = (unsigned int)&DAC12_1DAT; // speichere die Addresse des DAU Buffers
\end_layout

\begin_layout Plain Layout
	DMA2SA = (unsigned int)sinus; // und die unserer Werte
\end_layout

\begin_layout Plain Layout
	DMACTL0 = DMA2TSEL3; // Trigger kommt von TBCCR0
\end_layout

\begin_layout Plain Layout
	// kopiere 1 Byte vom String ins TX Buffer bei jedem Transfer und erhoehe
 src um eins
\end_layout

\begin_layout Plain Layout
	DMA2CTL = DMAEN + DMASRCINCR0 + DMASRCINCR1;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	// Bescheid sagen, wenn der Transfer fertig ist
\end_layout

\begin_layout Plain Layout
	BIT_CLR(DMA2CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout
	DMA2CTL += DMAIE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	_bis_SR_register(GIE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	// interrupt wird bei 0 ausgeloest
\end_layout

\begin_layout Plain Layout
	TBR = 1;
\end_layout

\begin_layout Plain Layout
//===Hier die Endlosschleife quasi das Betriebssystem=====================
\end_layout

\begin_layout Plain Layout
while(1){
\end_layout

\begin_layout Plain Layout
}	// Ende der Endlosschleife
\end_layout

\begin_layout Plain Layout
}	// Ende Main
\end_layout

\begin_layout Plain Layout
//====Ende des Hauptprogramms ============================================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#pragma vector = DACDMA_VECTOR
\end_layout

\begin_layout Plain Layout
__interrupt void DMA(void)
\end_layout

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
	// ISR aufgerufen, wenn der Transfer fertig ist
\end_layout

\begin_layout Plain Layout
	if (DMA2CTL & DMAIFG) {
\end_layout

\begin_layout Plain Layout
		BIT_CLR(DMA2CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout
		DMA2SZ = SINUS_VALUES;
\end_layout

\begin_layout Plain Layout
		DMA2DA = (unsigned int)&DAC12_1DAT; // speichere die Addresse des DAU
 Buffers
\end_layout

\begin_layout Plain Layout
		DMA2SA = (unsigned int)sinus; // und die unserer Werte
\end_layout

\begin_layout Plain Layout
		DMA2CTL += DMAEN;
\end_layout

\begin_layout Plain Layout
	}
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Einlesen von Analogwerten über den AD-Umsetzer im DMA-Mode 
\end_layout

\begin_layout Subsubsection
Entwickeln Sie ein Programm, das folgende Funktionalitäten bietet, wobei
 sich der Mikrocontroller in dem höchstmöglichsten Low Power Mode befindet:
 
\end_layout

\begin_layout Itemize
Durch einen Timer getaktet, sollen vom AD-Umsetzer (P6.7) 100 Messwerte in
 ein Array eingelesen werden (siehe A 8.1).
 Dabei soll der AD-Umsetzer über einen Zeitraum von 1 Sekunden 100 Meßwerte
 in äquidistanten Zeitintervallen von jeweils 0,01 Sekunde erfassen.
 Die Taktung der Wandlung des AD-Umsetzers soll ohne Interrupt über TB1
 (siehe A 6.5) als Taktquelle für den AD-Umsetzer erfolgen.
\end_layout

\begin_layout Itemize
Das Auslesen aus dem AD-Umsetzer und der Datentransport in das Array sollen
 per DMA erfolgen.
 Der DMA wird dabei durch das ADC12IFGx-Bit getriggert.
\end_layout

\begin_layout Itemize
Nach erfolgter Übertragung von 100 Messwerten durch die DMA, soll in der
 DMA-ISR der Mittelwert aus den 100 Messwerten berechnet werden
\end_layout

\begin_layout Itemize
Der Mittelwert soll als Zeichenkette mittels DMA auf die UART ausgegeben
 werden
\end_layout

\begin_layout Itemize
Der berechnete Mittelwert soll per DMA getriggert durch das UTXIFG1-Bit
 über die UART1 ausgegeben werden.
\end_layout

\begin_layout Itemize
Der ganze Prozess soll endlos laufen
\end_layout

\begin_layout Itemize
Schalten Sie während der Zeit der Mittelwertbildung und der Übertragung
 über die UART die LED (P4.0) ein.
\end_layout

\begin_layout Standard
\begin_inset listings
lstparams "basicstyle={\footnotesize},breaklines=true,frame=single,language=C,numbers=left,tabsize=4"
inline false
status open

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=========================================================================
\end_layout

\begin_layout Plain Layout
//=== Startprojekt zum Mikroprozessorpraktikum ============================
\end_layout

\begin_layout Plain Layout
//=========================================================================
\end_layout

\begin_layout Plain Layout
#include "msp430x16x.h"  	// Systemdefinitionen für den MSP430F1612
\end_layout

\begin_layout Plain Layout
#include "init.h"			// Initialisierung des Mikrocontrollers
\end_layout

\begin_layout Plain Layout
#include "system.h"			// Systemfunktionen MSB430H
\end_layout

\begin_layout Plain Layout
#include "interrupts.h"		// ISR - Interrupt Service Routinen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#include "HW_CC1100.h"		// CC1100 868MHz Funk Transceiver
\end_layout

\begin_layout Plain Layout
#include "HW_SHT11.h"		// SHT11 Feuchte- und Temperatursensor
\end_layout

\begin_layout Plain Layout
#include "HW_MMA7260Q.h"	// MMA7260Q 3D-Beschleunigungssensor
\end_layout

\begin_layout Plain Layout
#include "HW_LCD_TS.h"		// DOGM128 LCD Display Touchscreen
\end_layout

\begin_layout Plain Layout
#include "HW_LCD.h"			// DOGM128 LCD Display 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#include "stdio.h"			// Standard Libary 
\end_layout

\begin_layout Plain Layout
#include "string.h"			// Standard Libary 
\end_layout

\begin_layout Plain Layout
#include "math.h"			// Standard Libary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//#include "aufgabe_x.h"	// Header Datei für aufgabe_x.c 
\end_layout

\begin_layout Plain Layout
							// möglichst eigene xxx.h und xxx.c Dateien
\end_layout

\begin_layout Plain Layout
							// erstellen und verwenden.
\end_layout

\begin_layout Plain Layout
main(void);					//Haupprogramm
\end_layout

\begin_layout Plain Layout
void print_value(void);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
char buffer[16];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define BIT_SET(a,b) ((a) |= (b))
\end_layout

\begin_layout Plain Layout
#define BIT_CLR(a,b) ((a) &= ~(b))
\end_layout

\begin_layout Plain Layout
#define BIT_TOGGLE(a,b) ((a) ^= (b))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//====Hauptprogramm=======================================================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
int values[100];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
main(void)
\end_layout

\begin_layout Plain Layout
	{
\end_layout

\begin_layout Plain Layout
//===Hier sollten Variablen deklariert werden ============================
\end_layout

\begin_layout Plain Layout
	//unsigned char i = 0;
\end_layout

\begin_layout Plain Layout
	//char text[60];
\end_layout

\begin_layout Plain Layout
	//int x,y;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
//===Hier die notwendigen Initialisierungsschritte =======================
\end_layout

\begin_layout Plain Layout
//=(1)== Port-Initialisierung ============================================
\end_layout

\begin_layout Plain Layout
	init_Port();				// Initialisierung der Port Register
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
//(2)=== Clock-System-Initialisierung ====================================
\end_layout

\begin_layout Plain Layout
	//== XT2() oder Dco() als Taktquelle einstellen
\end_layout

\begin_layout Plain Layout
	//== durch Ein- oder Auskommentieren
\end_layout

\begin_layout Plain Layout
	//== DCO ist bei LPM Einsatz bevorzugt muß zyklisch kalibriert werden
\end_layout

\begin_layout Plain Layout
	//== XT2 ist quarzstabil muß nicht zyklisch kalibriert werden
\end_layout

\begin_layout Plain Layout
	//  			
\end_layout

\begin_layout Plain Layout
	//XT2 ();					// XT2 Taktquelle aktivieren mit 7.3728MHz
\end_layout

\begin_layout Plain Layout
	DCO ();					// Dco Taktquelle aktivieren mit 7.3728MHz
\end_layout

\begin_layout Plain Layout
	//						   beachte DELTA
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
//=(3)== Timer-Initialisierung= ==========================================
\end_layout

\begin_layout Plain Layout
	init_Timer_A();			// Init Timer für Sekundeninterrupt
\end_layout

\begin_layout Plain Layout
							// !! noch leere Funktion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=(4)== USART-Initialisierung ===========================================
\end_layout

\begin_layout Plain Layout
	init_UART1();			// UART-RS232 mit 115.2kBit/s initialisieren
\end_layout

\begin_layout Plain Layout
							// !! noch leere Funktion
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=(5)== CC1100-Transceiver-Initialisierung ==============================
\end_layout

\begin_layout Plain Layout
	init_UART0_SPI();		// CC1100 SPI UART initalisieren
\end_layout

\begin_layout Plain Layout
	init_CC1100_POWERDOWN();			// CC1100 init und in RX Mode setzen
\end_layout

\begin_layout Plain Layout
							// !!!Interrupte sind ab jetzt freigegeben!!
\end_layout

\begin_layout Plain Layout
	//== Adresse und Funkkanal des Transceivers setzen
\end_layout

\begin_layout Plain Layout
	//== für die Arbeitsplaetze HWPx (x=1...10) sollten
\end_layout

\begin_layout Plain Layout
	//== ID=x und channnel=x gesetzt werden
\end_layout

\begin_layout Plain Layout
	ID = 1;							// Adresse 
\end_layout

\begin_layout Plain Layout
	setUid(ID);						// Adresse im Transceiver setzen 
\end_layout

\begin_layout Plain Layout
	channel = 1; 					// Funkkanal  
\end_layout

\begin_layout Plain Layout
	switchFreq(channel);			// Funkkanal im Transceiver setzen 
\end_layout

\begin_layout Plain Layout
	//== Soll der Transceiver genutzt werden müssen folgende zwei Zeilen  
\end_layout

\begin_layout Plain Layout
	//== auskommentiert werden: 
\end_layout

\begin_layout Plain Layout
	init_CC1100_IDLE();		// CC1100 in den IDLE Mode setzen
\end_layout

\begin_layout Plain Layout
	init_CC1100_POWERDOWN();// CC1100 in den PowerDown Mode setzen
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//=(6)== LCD-Display-Initialisierung =====================================
\end_layout

\begin_layout Plain Layout
	dogm_reset();		// Hardware Reset des LCD Controllers
\end_layout

\begin_layout Plain Layout
	dogm_init();		// Initialisierung der LCD Controller Register
\end_layout

\begin_layout Plain Layout
	lcd_clear(WHITE);	// Grafikspeicher auf dem MSP430 löschen
\end_layout

\begin_layout Plain Layout
	//lcd_string(BLACK, 15, 25, "MSP430-GESTARTET!");	// Textausgabe
\end_layout

\begin_layout Plain Layout
	lcd_paint();		// Grafikspeicher auf das LCD Display ausgeben
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define LED_ROT (0x01)   // 0 0 1 P4.0
\end_layout

\begin_layout Plain Layout
#define LED_GELB (0x02)  // 0 1 0 P4.1
\end_layout

\begin_layout Plain Layout
#define LED_GRUEN (0x04) // 1 0 0 P4.2
\end_layout

\begin_layout Plain Layout
#define LED_ALL (LED_ROT | LED_GELB | LED_GRUEN)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define LED_ON(led) (BIT_CLR(P4OUT, led)) 
\end_layout

\begin_layout Plain Layout
#define LED_OFF(led) (BIT_SET(P4OUT, led)) 
\end_layout

\begin_layout Plain Layout
#define LED_TOGGLE(led) (BIT_TOGGLE(P4OUT, led))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define IS_LED_ON(led) (!(P4OUT & led))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define TASTE_LINKS (0x1)
\end_layout

\begin_layout Plain Layout
#define TASTE_RECHTS (0x2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#define SLEEP_QUANTUM 10000
\end_layout

\begin_layout Plain Layout
#define SLEEP(n) do { 		/* sleep for n seconds */ 
\backslash

\end_layout

\begin_layout Plain Layout
	long time = n * 100000; /* wait() sleeps 10*n microseconds */ 
\backslash

\end_layout

\begin_layout Plain Layout
	while(time > SLEEP_QUANTUM) { 
\backslash

\end_layout

\begin_layout Plain Layout
		wait(SLEEP_QUANTUM); 
\backslash

\end_layout

\begin_layout Plain Layout
		time -= SLEEP_QUANTUM; 
\backslash

\end_layout

\begin_layout Plain Layout
	} 
\backslash

\end_layout

\begin_layout Plain Layout
	wait(time); 
\backslash

\end_layout

\begin_layout Plain Layout
} while(0)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	memset(values, 0, 100*sizeof(int));
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	// waehle ACLK (32.7 kHz ohne divider)
\end_layout

\begin_layout Plain Layout
	BIT_CLR(TBCTL, TBSSEL0);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// wahle count up mode
\end_layout

\begin_layout Plain Layout
	BIT_SET(TBCTL, MC0);
\end_layout

\begin_layout Plain Layout
	BIT_CLR(TBCTL, MC1);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// setze anzahl fuer 100Hz Trigger
\end_layout

\begin_layout Plain Layout
	TBCCR0 = 327; // 32.7kHz: takt=32_768 / 100 = count to 327
\end_layout

\begin_layout Plain Layout
	//TBR = 1;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// loesche interrupt flag fuer timer
\end_layout

\begin_layout Plain Layout
	BIT_CLR(TBCCTL0, CCIFG);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	P6SEL |= BIT7; // P6.7 als input
\end_layout

\begin_layout Plain Layout
	ADC12CTL0 = ADC12ON + MSC;
\end_layout

\begin_layout Plain Layout
	// Trigger Timer_B.OUT0, SMCLK
\end_layout

\begin_layout Plain Layout
	ADC12CTL1 = CONSEQ1 + SHP;
\end_layout

\begin_layout Plain Layout
	ADC12MCTL0 = INCH_7;
\end_layout

\begin_layout Plain Layout
	ADC12IFG = 0;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// erlaube konversion
\end_layout

\begin_layout Plain Layout
	ADC12CTL0 |= ENC;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// DMA konfigurieren
\end_layout

\begin_layout Plain Layout
	DMA2SZ = 100;
\end_layout

\begin_layout Plain Layout
	DMA2SA = (unsigned int)&ADC12MEM0;	// speichere die Addresse des ADC Register
\end_layout

\begin_layout Plain Layout
	DMA2DA = (unsigned int)values;		// und die unserer Werte
\end_layout

\begin_layout Plain Layout
	DMACTL0 = DMA2TSEL2 + DMA2TSEL1;	// Trigger kommt vom ADC
\end_layout

\begin_layout Plain Layout
	// kopiere 1 Word aus dem ADC Register und erhoehe dst um eins
\end_layout

\begin_layout Plain Layout
	DMA2CTL = DMADT2 + DMAEN + DMADSTINCR0 + DMADSTINCR1;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// Bescheid sagen, wenn der Transfer fertig ist
\end_layout

\begin_layout Plain Layout
	BIT_CLR(DMA2CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout
	DMA2CTL += DMAIE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
	ADC12CTL0 |= ADC12SC;
\end_layout

\begin_layout Plain Layout
	_bis_SR_register(GIE);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
//===Hier die Endlosschleife quasi das Betriebssystem=====================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
while(1){
\end_layout

\begin_layout Plain Layout
	LPM3;
\end_layout

\begin_layout Plain Layout
}	// Ende der Endlosschleife
\end_layout

\begin_layout Plain Layout
}	// Ende Main
\end_layout

\begin_layout Plain Layout
//====Ende des Hauptprogramms ============================================
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
#pragma vector = DACDMA_VECTOR
\end_layout

\begin_layout Plain Layout
__interrupt void DMA(void)
\end_layout

\begin_layout Plain Layout
{
\end_layout

\begin_layout Plain Layout
	// fuer synchronisierung des transfers
\end_layout

\begin_layout Plain Layout
	static unsigned char transfer_done = 1;
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
	// starte keinen neuen transfer bis aktueller transfer fertig
\end_layout

\begin_layout Plain Layout
	if ((DMA2CTL & DMAIFG) && transfer_done) {
\end_layout

\begin_layout Plain Layout
		// wandlung fertig
\end_layout

\begin_layout Plain Layout
		double val = 0.0;
\end_layout

\begin_layout Plain Layout
		int i;
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		transfer_done = 0;
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		BIT_CLR(DMA2CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
		LED_ON(LED_ROT);
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		for (i = 0; i < 100; i++) {
\end_layout

\begin_layout Plain Layout
			double this = values[i];
\end_layout

\begin_layout Plain Layout
			
\end_layout

\begin_layout Plain Layout
			this /= 4096.0f;	// Wertbreite
\end_layout

\begin_layout Plain Layout
			this *= 3.3f;		// Referenzspannung
\end_layout

\begin_layout Plain Layout
			
\end_layout

\begin_layout Plain Layout
			val += this/100.0f;
\end_layout

\begin_layout Plain Layout
		}
\end_layout

\begin_layout Plain Layout
	
\end_layout

\begin_layout Plain Layout
		sprintf(buffer, "U=%.2f V
\backslash
r
\backslash
n", val);
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		// konfigurieren DMA fuer uart transfer
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		// USART konfigurieren		
\end_layout

\begin_layout Plain Layout
		BIT_CLR(IFG2, UTXIFG1);	// interrupt flag loeschen
\end_layout

\begin_layout Plain Layout
		BIT_CLR(IE2, UTXIE1);	// interrupt ausschaulten
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
		// DMA konfigurieren
\end_layout

\begin_layout Plain Layout
		DMA1SZ = strlen(buffer);
\end_layout

\begin_layout Plain Layout
		DMA1DA = (unsigned int)&U1TXBUF; // speichere die Addresse des TX Buffers
\end_layout

\begin_layout Plain Layout
		DMA1SA = (unsigned int)buffer; // und die von unserem String
\end_layout

\begin_layout Plain Layout
		BIT_SET(DMACTL0, DMA1TSEL3 + DMA1TSEL1); // Trigger wenn TX IFG gestezt
 ist
\end_layout

\begin_layout Plain Layout
		// kopiere 1 Byte vom String ins TX Buffer bei jedem Transfer und erhoehe
 src um eins
\end_layout

\begin_layout Plain Layout
		DMA1CTL = DMAEN + DMASRCINCR0 + DMASRCINCR1 + DMADSTBYTE + DMASRCBYTE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
		// Bescheid sagen, wenn der Transfer fertig ist
\end_layout

\begin_layout Plain Layout
		BIT_CLR(DMA1CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout
		DMA1CTL += DMAIE;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
		BIT_SET(IFG2, UTXIFG1); // starte den ersten Transfer
\end_layout

\begin_layout Plain Layout
		
\end_layout

\begin_layout Plain Layout
	} else if (DMA1CTL & DMAIFG) {
\end_layout

\begin_layout Plain Layout
		// uart transfer fertig
\end_layout

\begin_layout Plain Layout
		transfer_done = 1;
\end_layout

\begin_layout Plain Layout
		BIT_CLR(DMA1CTL, DMAIFG);
\end_layout

\begin_layout Plain Layout
		LED_OFF(LED_ROT);
\end_layout

\begin_layout Plain Layout
	}
\end_layout

\begin_layout Plain Layout
}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Bestimmen Sie mit dem Counter HM8021 messtechnisch die Zeit für die Berechnung
 des Mittelwertes und die anschließende Datenübertragung über die UART.
 Nutzen Sie dazu den Port P1 Bit2 als Signalquelle für die Messung.
 Der Vorgang muß innerhalb einer Sekunde zyklisch ablaufen damit das Messgerät
 richtig funktioniert (also Tastendruck per Software emulieren).
\end_layout

\begin_layout Standard
Zusätzlich zum An- und Ausschalten der roten LED fügen wir ein BIT_SET(P1OUT,
 BIT2) und BIT_CLR(P1OUT, BIT2) ein.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Messung (Zeit für Berechnung und Übertragung): 
\begin_inset Formula $22,2\, ms$
\end_inset


\end_layout

\end_body
\end_document
